import { logError } from '../../shared/logger';
import { Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import { YapiKrediFASTEmailService } from './emailService';
import { PaymentMatchingService } from './paymentMatchingService';
import { PDFParserService } from './pdfParserService';
import { processPDFToDatabase } from './etlService';
import * as multer from 'multer';
import * as path from 'path';

const prisma = new PrismaClient();

export class BankingController {
  private emailService: YapiKrediFASTEmailService;
  private matchingService: PaymentMatchingService;
  private pdfParserService: PDFParserService;

  constructor() {
    this.emailService = new YapiKrediFASTEmailService();
    this.matchingService = new PaymentMatchingService();
    this.pdfParserService = new PDFParserService();
  }

  // Otomatik email √ßekme
  async fetchEmails(req: Request, res: Response) {
    try {
      console.log('üìß Otomatik email √ßekme ba≈ülatƒ±lƒ±yor...');
      
      const emails = await this.emailService.fetchYapiKrediFASTEmails();
      
      if (emails.length === 0) {
        return res.json({
          success: true,
          message: 'Yeni email bulunamadƒ±',
          data: { processed: 0, transactions: [] }
        });
      }

      const processedTransactions = [];
      let duplicateCount = 0;

      for (const emailData of emails) {
        try {
          // Duplikasyon kontrol√º
          const existingTransaction = await prisma.bankTransaction.findFirst({
            where: { messageId: emailData.transaction.messageId }
          });

          if (existingTransaction) {
            duplicateCount++;
            continue;
          }

          // ƒ∞≈ülemi kaydet
          const savedTransaction = await prisma.bankTransaction.create({
            data: emailData.transaction
          });

          // Otomatik e≈üle≈ütirme
          const matchResult = await this.matchingService.matchTransaction(savedTransaction);
          await this.matchingService.saveMatchResult(savedTransaction.id, matchResult);

          processedTransactions.push({
            transaction: savedTransaction,
            matchResult
          });

        } catch (error) {
          logError('Email i≈üleme hatasƒ±:', error);
        }
      }

      const metrics = this.emailService.getMetrics();

      return res.json({
        success: true,
        message: `${processedTransactions.length} email i≈ülendi, ${duplicateCount} duplikasyon`,
        data: {
          processed: processedTransactions.length,
          duplicates: duplicateCount,
          transactions: processedTransactions,
          metrics
        }
      });

    } catch (error) {
      logError('Otomatik email √ßekme hatasƒ±:', error);
      return res.status(500).json({
        success: false,
        message: 'Email √ßekme sƒ±rasƒ±nda hata olu≈ütu',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  // Email i≈üleme (manuel)
  async processEmail(req: Request, res: Response) {
    try {
      const { emailContent, emailSubject, messageId } = req.body;

      if (!emailContent || !messageId) {
        return res.status(400).json({
          success: false,
          message: 'Email i√ßeriƒüi ve messageId gerekli'
        });
      }

      // Email parsing
      const transaction = await this.parseYapiKrediEmail(emailContent, emailSubject, messageId);
      
      if (!transaction) {
        return res.status(400).json({
          success: false,
          message: 'Email parse edilemedi'
        });
      }

      // Duplikasyon kontrol√º
      const existingTransaction = await prisma.bankTransaction.findFirst({
        where: { messageId: transaction.messageId }
      });

      if (existingTransaction) {
        return res.status(409).json({
          success: false,
          message: 'Bu i≈ülem zaten mevcut',
          transactionId: existingTransaction.id
        });
      }

      // ƒ∞≈ülemi kaydet
      const savedTransaction = await prisma.bankTransaction.create({
        data: transaction
      });

      // Otomatik e≈üle≈ütirme
      const matchResult = await this.matchingService.matchTransaction(savedTransaction);
      await this.matchingService.saveMatchResult(savedTransaction.id, matchResult);

      return res.json({
        success: true,
        message: 'Email ba≈üarƒ±yla i≈ülendi',
        data: {
          transaction: savedTransaction,
          matchResult
        }
      });

    } catch (error) {
      logError('Email i≈üleme hatasƒ±:', error);
      return res.status(500).json({
        success: false,
        message: 'Email i≈ülenirken hata olu≈ütu'
      });
    }
  }

  // Banka i≈ülemlerini getir
  async getBankTransactions(req: Request, res: Response) {
    try {
      const { page = 1, limit = 20, direction, isMatched, startDate, endDate } = req.query;
      
      const pageNum = parseInt(page as string) || 1;
      const limitNum = parseInt(limit as string) || 20;
      const skip = (pageNum - 1) * limitNum;

      // Filtreleme ko≈üullarƒ±
      const where: any = {};
      
      if (direction) where.direction = direction;
      if (isMatched !== undefined) where.isMatched = isMatched === 'true';
      if (startDate || endDate) {
        where.transactionDate = {};
        if (startDate) where.transactionDate.gte = new Date(startDate as string);
        if (endDate) where.transactionDate.lte = new Date(endDate as string);
      }

      // Toplam sayƒ±
      const total = await prisma.bankTransaction.count({ where });

      // ƒ∞≈ülemleri getir
      const transactions = await prisma.bankTransaction.findMany({
        where,
        include: {
          customer: {
            select: {
              id: true,
              name: true,
              code: true
            }
          },
          paymentMatches: {
            include: {
              customer: {
                select: {
                  id: true,
                  name: true,
                  code: true
                }
              }
            }
          }
        },
        orderBy: { transactionDate: 'desc' },
        skip,
        take: limitNum
      });

      return res.json({
        success: true,
        data: {
          transactions,
          pagination: {
            page: pageNum,
            limit: limitNum,
            total,
            pages: Math.ceil(total / limitNum)
          }
        }
      });

    } catch (error) {
      logError('Banka i≈ülemleri getirme hatasƒ±:', error);
      return res.status(500).json({
        success: false,
        error: 'Banka i≈ülemleri getirilemedi'
      });
    }
  }

  // PDF i≈ülemlerini getir
  async getPDFTransactions(req: Request, res: Response) {
    try {
      const { page = 1, limit = 50, direction, category, startDate, endDate } = req.query;
      
      const pageNum = parseInt(page as string) || 1;
      const limitNum = parseInt(limit as string) || 50;
      const skip = (pageNum - 1) * limitNum;

      // Filtreleme ko≈üullarƒ±
      const where: any = {};
      
      if (direction) where.direction = direction;
      if (category) where.category = category;
      if (startDate || endDate) {
        where.dateTimeIso = {};
        if (startDate) where.dateTimeIso.gte = startDate as string;
        if (endDate) where.dateTimeIso.lte = endDate as string;
      }

      // Toplam sayƒ±
      const total = await prisma.pDFTransaction.count({ where });

      // ƒ∞≈ülemleri getir
      const transactions = await prisma.pDFTransaction.findMany({
        where,
        orderBy: { dateTimeIso: 'desc' },
        skip,
        take: limitNum
      });

      return res.json({
        success: true,
        data: {
          transactions,
          pagination: {
            page: pageNum,
            limit: limitNum,
            total,
            pages: Math.ceil(total / limitNum)
          }
        }
      });

    } catch (error) {
      logError('PDF i≈ülemleri getirme hatasƒ±:', error);
      return res.status(500).json({
        success: false,
        error: 'PDF i≈ülemleri getirilemedi'
      });
    }
  }

  // E≈üle≈ümemi≈ü √∂demeleri getir
  async getUnmatchedPayments(req: Request, res: Response) {
    try {
      const { page = 1, limit = 20 } = req.query;
      
      const pageNum = parseInt(page as string) || 1;
      const limitNum = parseInt(limit as string) || 20;
      const skip = (pageNum - 1) * limitNum;

      // Toplam sayƒ±
      const total = await prisma.bankTransaction.count({
        where: { isMatched: false }
      });

      // E≈üle≈ümemi≈ü i≈ülemleri getir
      const transactions = await prisma.bankTransaction.findMany({
        where: { isMatched: false },
        orderBy: { transactionDate: 'desc' },
        skip,
        take: limitNum
      });

      return res.json({
        success: true,
        data: {
          transactions,
          pagination: {
            page: pageNum,
            limit: limitNum,
            total,
            pages: Math.ceil(total / limitNum)
          }
        }
      });

    } catch (error) {
      logError('E≈üle≈ümemi≈ü √∂demeler getirme hatasƒ±:', error);
      return res.status(500).json({
        success: false,
        error: 'E≈üle≈ümemi≈ü √∂demeler getirilemedi'
      });
    }
  }

  // Manuel √∂deme e≈üle≈ütirme
  async matchPayment(req: Request, res: Response) {
    try {
      const { transactionId, customerId } = req.body;
      
      if (!transactionId || !customerId) {
        return res.status(400).json({
          success: false,
          error: 'Transaction ID ve Customer ID gerekli'
        });
      }

      // Transaction'ƒ± getir
      const transaction = await prisma.bankTransaction.findUnique({
        where: { id: transactionId }
      });
      
      if (!transaction) {
        return res.status(404).json({
          success: false,
          error: 'ƒ∞≈ülem bulunamadƒ±'
        });
      }

      // M√º≈üteriyi getir
      const customer = await prisma.customer.findUnique({
        where: { id: customerId }
      });
      
      if (!customer) {
        return res.status(404).json({
          success: false,
          error: 'M√º≈üteri bulunamadƒ±'
        });
      }

      // Manuel e≈üle≈ütirme sonucu olu≈ütur
      const matchResult = {
        matched: true,
        customer: customer,
        confidence: 1.0,
        methods: ['manual_match']
      };

      // E≈üle≈ütirmeyi kaydet
      await this.matchingService.saveMatchResult(transactionId, matchResult);

      return res.json({
        success: true,
        message: 'E≈üle≈ütirme ba≈üarƒ±yla kaydedildi',
        data: {
          transaction: transaction,
          customer: customer,
          confidence: 1.0
        }
      });

    } catch (error) {
      logError('Manuel e≈üle≈ütirme hatasƒ±:', error);
      return res.status(500).json({
        success: false,
        error: 'Manuel e≈üle≈ütirme yapƒ±lamadƒ±'
      });
    }
  }

  // Email ayarlarƒ±
  async getEmailSettings(req: Request, res: Response) {
    try {
      const settings = {
        host: process.env.EMAIL_HOST || process.env.MAIL_HOST,
        port: process.env.EMAIL_PORT || process.env.MAIL_PORT,
        user: process.env.EMAIL_USER || process.env.MAIL_USER,
        from: process.env.YAPIKREDI_FROM_EMAIL,
        subjectFilter: process.env.YAPIKREDI_SUBJECT_FILTER,
        autoProcess: (process.env.YAPIKREDI_AUTO_PROCESS || 'false').toLowerCase() === 'true',
        realtimeMonitoring: (process.env.YAPIKREDI_REALTIME_MONITORING || 'false').toLowerCase() === 'true',
        isConfigured: !!((process.env.EMAIL_HOST || process.env.MAIL_HOST) && (process.env.EMAIL_USER || process.env.MAIL_USER) && (process.env.EMAIL_PASS || process.env.MAIL_PASS))
      };

      return res.json({
        success: true,
        data: settings
      });

    } catch (error) {
      logError('Email ayarlarƒ± getirme hatasƒ±:', error);
      return res.status(500).json({
        success: false,
        error: 'Email ayarlarƒ± getirilemedi'
      });
    }
  }

  // Email baƒülantƒ± testi
  async testEmailConnection(req: Request, res: Response) {
    try {
      const isConnected = await this.emailService.testConnection();
      
      return res.json({
        success: true,
        data: {
          connected: isConnected
        }
      });

    } catch (error) {
      logError('Email baƒülantƒ± testi hatasƒ±:', error);
      return res.status(500).json({
        success: false,
        error: 'Email baƒülantƒ± testi yapƒ±lamadƒ±'
      });
    }
  }

  // E≈üle≈ütirme istatistikleri
  async getMatchingStats(req: Request, res: Response) {
    try {
      const totalTransactions = await prisma.bankTransaction.count();
      const matchedTransactions = await prisma.bankTransaction.count({
        where: { isMatched: true }
      });
      const unmatchedTransactions = totalTransactions - matchedTransactions;

      const stats = {
        total: totalTransactions,
        matched: matchedTransactions,
        unmatched: unmatchedTransactions,
        matchRate: totalTransactions > 0 ? (matchedTransactions / totalTransactions) * 100 : 0
      };

      return res.json({
        success: true,
        data: stats
      });

    } catch (error) {
      logError('E≈üle≈ütirme istatistikleri hatasƒ±:', error);
      return res.status(500).json({
        success: false,
        error: 'E≈üle≈ütirme istatistikleri getirilemedi'
      });
    }
  }

  // Otomatik e≈üle≈ütirme √ßalƒ±≈ütƒ±r
  async runAutoMatching(req: Request, res: Response) {
    try {
      const { limit = 100 } = req.query;
      const limitNum = parseInt(limit as string) || 100;

      // E≈üle≈ümemi≈ü i≈ülemleri getir
      const unmatchedTransactions = await prisma.bankTransaction.findMany({
        where: { isMatched: false },
        take: limitNum,
        orderBy: { transactionDate: 'desc' }
      });

      let matchedCount = 0;
      const results = [];

      for (const transaction of unmatchedTransactions) {
        try {
          const matchResult = await this.matchingService.matchTransaction(transaction);
          
          if (matchResult.matched) {
            await this.matchingService.saveMatchResult(transaction.id, matchResult);
            matchedCount++;
          }

          results.push({
            transactionId: transaction.id,
            matched: matchResult.matched,
            confidence: matchResult.confidence,
            customer: matchResult.customer?.name || null
          });

        } catch (error) {
          logError(`ƒ∞≈ülem e≈üle≈ütirme hatasƒ± (${transaction.id}):`, error);
          results.push({
            transactionId: transaction.id,
            matched: false,
            error: error instanceof Error ? error.message : 'Unknown error'
          });
        }
      }

      return res.json({
        success: true,
        message: `${matchedCount} i≈ülem e≈üle≈ütirildi`,
        data: {
          processed: unmatchedTransactions.length,
          matched: matchedCount,
          results
        }
      });

    } catch (error) {
      logError('Otomatik e≈üle≈ütirme hatasƒ±:', error);
      return res.status(500).json({
        success: false,
        error: 'Otomatik e≈üle≈ütirme √ßalƒ±≈ütƒ±rƒ±lamadƒ±'
      });
    }
  }

  // Private methods
  private async parseYapiKrediEmail(emailContent: any, emailSubject: string, messageId: string) {
    try {
      // Email service'i kullanarak parse et
      const mockEmail = {
        html: emailContent,
        subject: emailSubject,
        messageId: messageId,
        from: '',
        date: new Date()
      };

      return await this.emailService.parseYapiKrediFASTEmail(mockEmail);
    } catch (error) {
      logError('Email parse hatasƒ±:', error);
      return null;
    }
  }

  // Email istatistikleri
  async getEmailStats(req: Request, res: Response) {
    try {
      const stats = await this.emailService.getEmailStats();
      
      return res.json({
        success: true,
        data: stats
      });
    } catch (error) {
      logError('Email istatistikleri hatasƒ±:', error);
      return res.status(500).json({
        success: false,
        error: 'Email istatistikleri getirilemedi'
      });
    }
  }

  // Tarih aralƒ±ƒüƒ±nda email √ßekme
  async fetchEmailsByDateRange(req: Request, res: Response) {
    try {
      const { startDate, endDate } = req.body;

      if (!startDate || !endDate) {
        return res.status(400).json({
          success: false,
          message: 'Ba≈ülangƒ±√ß ve biti≈ü tarihi gerekli'
        });
      }

      const start = new Date(startDate);
      const end = new Date(endDate);

      if (isNaN(start.getTime()) || isNaN(end.getTime())) {
        return res.status(400).json({
          success: false,
          message: 'Ge√ßersiz tarih formatƒ±'
        });
      }

      const emails = await this.emailService.fetchEmailsByDateRange(start, end);
      
      const processedTransactions = [];
      let duplicateCount = 0;

      for (const emailData of emails) {
        try {
          // Duplikasyon kontrol√º
          const existingTransaction = await prisma.bankTransaction.findFirst({
            where: { messageId: emailData.transaction.messageId }
          });

          if (existingTransaction) {
            duplicateCount++;
            continue;
          }

          // ƒ∞≈ülemi kaydet
          const savedTransaction = await prisma.bankTransaction.create({
            data: emailData.transaction
          });

          // Otomatik e≈üle≈ütirme
          const matchResult = await this.matchingService.matchTransaction(savedTransaction);
          await this.matchingService.saveMatchResult(savedTransaction.id, matchResult);

          processedTransactions.push({
            transaction: savedTransaction,
            matchResult
          });

        } catch (error) {
          logError('Email i≈üleme hatasƒ±:', error);
        }
      }

      return res.json({
        success: true,
        message: `${processedTransactions.length} email i≈ülendi, ${duplicateCount} duplikasyon`,
        data: {
          processed: processedTransactions.length,
          duplicates: duplicateCount,
          transactions: processedTransactions,
          dateRange: { startDate: start, endDate: end }
        }
      });

    } catch (error) {
      logError('Tarih aralƒ±ƒüƒ± email √ßekme hatasƒ±:', error);
      return res.status(500).json({
        success: false,
        error: 'Tarih aralƒ±ƒüƒ±nda email √ßekilemedi'
      });
    }
  }

  // Realtime monitoring ba≈ülat
  async startRealtimeMonitoring(req: Request, res: Response) {
    try {
      // WebSocket veya Server-Sent Events kullanarak realtime callback
      // Bu √∂rnekte basit bir response d√∂nd√ºr√ºyoruz
      // Ger√ßek uygulamada WebSocket baƒülantƒ±sƒ± kurulmalƒ±
      
      await this.emailService.startRealtimeMonitoring((transaction) => {
        // Bu callback'te WebSocket ile frontend'e bildirim g√∂nderilmeli
        console.log('üîÑ Yeni i≈ülem tespit edildi:', transaction);
      });

      return res.json({
        success: true,
        message: 'Realtime monitoring ba≈ülatƒ±ldƒ±'
      });

    } catch (error) {
      logError('Realtime monitoring ba≈ülatma hatasƒ±:', error);
      return res.status(500).json({
        success: false,
        error: 'Realtime monitoring ba≈ülatƒ±lamadƒ±'
      });
    }
  }

  // Realtime monitoring durdur
  async stopRealtimeMonitoring(req: Request, res: Response) {
    try {
      await this.emailService.stopRealtimeMonitoring();

      return res.json({
        success: true,
        message: 'Realtime monitoring durduruldu'
      });

    } catch (error) {
      logError('Realtime monitoring durdurma hatasƒ±:', error);
      return res.status(500).json({
        success: false,
        error: 'Realtime monitoring durdurulamadƒ±'
      });
    }
  }

  // Email ayarlarƒ±nƒ± g√ºncelle
  async updateEmailSettings(req: Request, res: Response) {
    try {
      const { host, port, user, pass, secure } = req.body;

      const success = await this.emailService.updateEmailSettings({
        host, port, user, pass, secure
      });

      if (success) {
        return res.json({
          success: true,
          message: 'Email ayarlarƒ± g√ºncellendi'
        });
      } else {
        return res.status(400).json({
          success: false,
          error: 'Email ayarlarƒ± g√ºncellenemedi'
        });
      }

    } catch (error) {
      logError('Email ayarlarƒ± g√ºncelleme hatasƒ±:', error);
      return res.status(500).json({
        success: false,
        error: 'Email ayarlarƒ± g√ºncellenemedi'
      });
    }
  }

  // Eksik i≈ülemleri tespit et
  async detectMissingTransactions(req: Request, res: Response) {
    try {
      console.log('üîç Eksik i≈ülem tespiti ba≈ülatƒ±lƒ±yor...');
      
      // T√ºm i≈ülemleri getir
      const transactions = await prisma.bankTransaction.findMany({
        orderBy: {
          transactionDate: 'asc'
        }
      });
      
      if (transactions.length === 0) {
        return res.json({
          success: true,
          data: {
            missingTransactions: [],
            summary: {
              totalGaps: 0,
              totalDifference: 0,
              criticalIssues: 0
            }
          }
        });
      }
      
      // Ba≈ülangƒ±√ß bakiyesini hesapla
      const firstTransaction = transactions[0];
      const startBalance = (firstTransaction.balanceAfter || 0) - 
        (firstTransaction.direction === 'IN' ? firstTransaction.amount : -firstTransaction.amount);
      
      // Her i≈ülem i√ßin bakiye farkƒ±nƒ± hesapla
      let currentBalance = startBalance;
      const balanceGaps = [];
      
      for (let i = 0; i < transactions.length; i++) {
        const tx = transactions[i];
        
        // ƒ∞≈ülem tutarƒ±nƒ± hesapla
        if (tx.direction === 'IN') {
          currentBalance += tx.amount;
        } else {
          currentBalance -= tx.amount;
        }
        
        // Bakiye farkƒ±nƒ± hesapla
        if (tx.balanceAfter) {
          const difference = tx.balanceAfter - currentBalance;
          
          if (Math.abs(difference) > 1.0) { // 1 TL'den fazla fark
            balanceGaps.push({
              index: i,
              transaction: tx,
              expectedBalance: currentBalance,
              actualBalance: tx.balanceAfter,
              difference: difference,
              missingAmount: Math.abs(difference),
              isCritical: Math.abs(difference) > 100
            });
          }
        }
      }
      
      // G√ºnl√ºk analiz
      const dailyGaps: Record<string, {
        gaps: any[];
        totalDifference: number;
        criticalGaps: number;
      }> = {};
      balanceGaps.forEach(gap => {
        const date = gap.transaction.transactionDate.toISOString().split('T')[0];
        if (!dailyGaps[date]) {
          dailyGaps[date] = {
            gaps: [],
            totalDifference: 0,
            criticalGaps: 0
          };
        }
        dailyGaps[date].gaps.push(gap);
        dailyGaps[date].totalDifference += gap.difference;
        if (gap.isCritical) {
          dailyGaps[date].criticalGaps++;
        }
      });
      
      // Eksik i≈ülem tahminleri
      const missingTransactions: any[] = [];
      Object.keys(dailyGaps).forEach(date => {
        const day = dailyGaps[date];
        if (Math.abs(day.totalDifference) > 1000) {
          missingTransactions.push({
            date: date,
            estimatedAmount: Math.abs(day.totalDifference),
            direction: day.totalDifference > 0 ? 'IN' : 'OUT',
            confidence: 'Y√ºksek',
            criticalGaps: day.criticalGaps,
            totalGaps: day.gaps.length,
            transactions: day.gaps.map((gap: any) => ({
              id: gap.transaction.id,
              counterpartyName: gap.transaction.counterpartyName,
              amount: gap.transaction.amount,
              direction: gap.transaction.direction,
              transactionDate: gap.transaction.transactionDate,
              difference: gap.difference,
              isCritical: gap.isCritical
            }))
          });
        }
      });
      
      // √ñzet bilgiler
      const totalDifference = balanceGaps.reduce((sum, gap) => sum + Math.abs(gap.difference), 0);
      const criticalIssues = balanceGaps.filter(gap => gap.isCritical).length;
      
      const summary = {
        totalGaps: balanceGaps.length,
        totalDifference: totalDifference,
        criticalIssues: criticalIssues,
        missingTransactionsCount: missingTransactions.length,
        startBalance: startBalance,
        endBalance: currentBalance,
        severity: totalDifference > 10000 ? 'CRITICAL' : totalDifference > 1000 ? 'HIGH' : 'LOW'
      };
      
      return res.json({
        success: true,
        data: {
          missingTransactions,
          balanceGaps: balanceGaps.map(gap => ({
            id: gap.transaction.id,
            counterpartyName: gap.transaction.counterpartyName,
            transactionDate: gap.transaction.transactionDate,
            amount: gap.transaction.amount,
            direction: gap.transaction.direction,
            expectedBalance: gap.expectedBalance,
            actualBalance: gap.actualBalance,
            difference: gap.difference,
            isCritical: gap.isCritical
          })),
          summary
        }
      });
      
    } catch (error) {
      console.error('‚ùå Eksik i≈ülem tespiti hatasƒ±:', error);
      const errorMessage = error instanceof Error ? error.message : 'Bilinmeyen hata';
      return res.status(500).json({
        success: false,
        message: 'Eksik i≈ülem tespiti sƒ±rasƒ±nda hata olu≈ütu',
        error: errorMessage
      });
    }
  }

  // PDF hesap hareketlerini parse et ve eksik i≈ülemleri tespit et
  async parsePDFTransactions(req: Request, res: Response) {
    try {
      if (!req.file) {
        return res.status(400).json({
          success: false,
          message: 'PDF dosyasƒ± y√ºklenmedi'
        });
      }

      const filePath = req.file.path;
      console.log(`üìÑ PDF dosyasƒ± y√ºklendi: ${filePath}`);

      // PDF'i parse et
      const result = await this.pdfParserService.parsePDF(filePath);
      
      // Mevcut sistem i≈ülemlerini al
      const existingTransactions = await prisma.bankTransaction.findMany({
        where: {
          transactionDate: {
            gte: result.accountInfo?.startDate || new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), // Son 30 g√ºn
            lte: result.accountInfo?.endDate || new Date()
          }
        },
        orderBy: {
          transactionDate: 'asc'
        }
      });

      console.log(`üìä Mevcut sistem i≈ülemleri alƒ±ndƒ±: ${existingTransactions.length} i≈ülem`);
      
      // Eksik i≈ülemleri tespit et (eƒüer metod varsa)
      let missingAnalysis = null;
      try {
        if (typeof this.pdfParserService.detectMissingTransactions === 'function') {
          missingAnalysis = await this.pdfParserService.detectMissingTransactions(
            result.transactions, 
            existingTransactions
          );
        }
      } catch (missingError) {
        console.log('Eksik i≈ülem tespiti yapƒ±lamadƒ±:', missingError);
        // Eksik i≈ülem tespiti ba≈üarƒ±sƒ±z olsa bile PDF parsing ba≈üarƒ±lƒ±
      }

      return res.json({
        success: true,
        message: 'PDF ba≈üarƒ±yla parse edildi',
        data: {
          ...result,
          existingTransactions: existingTransactions.length,
          missingAnalysis
        }
      });

    } catch (error) {
      logError('PDF parsing hatasƒ±:', error);
      return res.status(500).json({
        success: false,
        message: 'PDF parse edilirken hata olu≈ütu',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  // PDF'den √ßƒ±karƒ±lan i≈ülemleri sisteme kaydet
  async savePDFTransactions(req: Request, res: Response) {
    try {
      const { transactions, accountInfo } = req.body;

      if (!transactions || !Array.isArray(transactions)) {
        return res.status(400).json({
          success: false,
          message: 'Ge√ßerli i≈ülem verisi gerekli'
        });
      }

      const savedTransactions = [];
      let duplicateCount = 0;

      for (const tx of transactions) {
        try {
          // Duplikasyon kontrol√º
          const existingTransaction = await prisma.bankTransaction.findFirst({
            where: {
              transactionDate: new Date(tx.date),
              amount: tx.credit > 0 ? tx.credit : tx.debit,
              direction: tx.credit > 0 ? 'IN' : 'OUT'
            }
          });

          if (existingTransaction) {
            duplicateCount++;
            continue;
          }

          // Banka i≈ülemi olarak kaydet
          const savedTransaction = await prisma.bankTransaction.create({
            data: {
              messageId: `PDF_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
              bankCode: 'PDF_IMPORT',
              direction: tx.credit > 0 ? 'IN' : 'OUT',
              accountIban: accountInfo.accountNumber || 'UNKNOWN',
              transactionDate: new Date(tx.date),
              amount: tx.credit > 0 ? tx.credit : tx.debit,
              senderName: tx.description,
              counterpartyName: tx.description,
              balanceAfter: tx.balance,
              isMatched: false,
              rawEmailData: JSON.stringify(tx),
              parsedData: JSON.stringify({
                source: 'PDF_IMPORT',
                accountInfo,
                originalTransaction: tx
              })
            }
          });

          savedTransactions.push(savedTransaction);

        } catch (error) {
          logError('ƒ∞≈ülem kaydetme hatasƒ±:', error);
        }
      }

      return res.json({
        success: true,
        message: `${savedTransactions.length} i≈ülem kaydedildi, ${duplicateCount} duplikasyon`,
        data: {
          saved: savedTransactions.length,
          duplicates: duplicateCount,
          transactions: savedTransactions
        }
      });

    } catch (error) {
      logError('PDF i≈ülem kaydetme hatasƒ±:', error);
      return res.status(500).json({
        success: false,
        message: 'ƒ∞≈ülemler kaydedilirken hata olu≈ütu',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  // Tek i≈ülem sil
  async deleteTransaction(req: Request, res: Response) {
    try {
      const { transactionId } = req.params;

      if (!transactionId) {
        return res.status(400).json({
          success: false,
          message: 'ƒ∞≈ülem ID gerekli'
        });
      }

      // ƒ∞≈ülemi bul
      const transaction = await prisma.bankTransaction.findUnique({
        where: { id: transactionId }
      });

      if (!transaction) {
        return res.status(404).json({
          success: false,
          message: 'ƒ∞≈ülem bulunamadƒ±'
        });
      }

      // ƒ∞li≈ükili e≈üle≈ütirmeleri sil
      await prisma.paymentMatch.deleteMany({
        where: { bankTransactionId: transactionId }
      });

      // ƒ∞≈ülemi sil
      await prisma.bankTransaction.delete({
        where: { id: transactionId }
      });

      return res.json({
        success: true,
        message: 'ƒ∞≈ülem ba≈üarƒ±yla silindi',
        data: {
          deletedTransaction: transaction
        }
      });

    } catch (error) {
      logError('ƒ∞≈ülem silme hatasƒ±:', error);
      return res.status(500).json({
        success: false,
        message: 'ƒ∞≈ülem silinirken hata olu≈ütu',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  // Toplu i≈ülem silme
  async deleteTransactions(req: Request, res: Response) {
    try {
      const { 
        transactionIds, 
        startDate, 
        endDate, 
        direction, 
        isMatched,
        bankCode,
        minAmount,
        maxAmount
      } = req.body;

      let whereClause: any = {};

      // ID listesi varsa onlarƒ± kullan
      if (transactionIds && Array.isArray(transactionIds) && transactionIds.length > 0) {
        whereClause.id = { in: transactionIds };
      } else {
        // Filtreleme kriterleri
        if (startDate || endDate) {
          whereClause.transactionDate = {};
          if (startDate) whereClause.transactionDate.gte = new Date(startDate);
          if (endDate) whereClause.transactionDate.lte = new Date(endDate);
        }

        if (direction) whereClause.direction = direction;
        if (isMatched !== undefined) whereClause.isMatched = isMatched;
        if (bankCode) whereClause.bankCode = bankCode;

        if (minAmount || maxAmount) {
          whereClause.amount = {};
          if (minAmount) whereClause.amount.gte = parseFloat(minAmount);
          if (maxAmount) whereClause.amount.lte = parseFloat(maxAmount);
        }
      }

      // Silinecek i≈ülemleri bul
      const transactionsToDelete = await prisma.bankTransaction.findMany({
        where: whereClause,
        include: {
          paymentMatches: true
        }
      });

      if (transactionsToDelete.length === 0) {
        return res.json({
          success: true,
          message: 'Silinecek i≈ülem bulunamadƒ±',
          data: {
            deletedCount: 0,
            totalAmount: 0
          }
        });
      }

      // ƒ∞li≈ükili e≈üle≈ütirmeleri sil
      const transactionIdsToDelete = transactionsToDelete.map(tx => tx.id);
      await prisma.paymentMatch.deleteMany({
        where: { bankTransactionId: { in: transactionIdsToDelete } }
      });

      // ƒ∞≈ülemleri sil
      await prisma.bankTransaction.deleteMany({
        where: whereClause
      });

      const totalAmount = transactionsToDelete.reduce((sum, tx) => sum + tx.amount, 0);

      return res.json({
        success: true,
        message: `${transactionsToDelete.length} i≈ülem ba≈üarƒ±yla silindi`,
        data: {
          deletedCount: transactionsToDelete.length,
          totalAmount: totalAmount,
          deletedTransactions: transactionsToDelete.map(tx => ({
            id: tx.id,
            date: tx.transactionDate,
            amount: tx.amount,
            direction: tx.direction,
            description: tx.counterpartyName
          }))
        }
      });

    } catch (error) {
      logError('Toplu i≈ülem silme hatasƒ±:', error);
      return res.status(500).json({
        success: false,
        message: 'ƒ∞≈ülemler silinirken hata olu≈ütu',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  // Eski i≈ülemleri temizle (belirli tarihten √∂nceki)
  async cleanupOldTransactions(req: Request, res: Response) {
    try {
      const { beforeDate, dryRun = false } = req.body;

      console.log('üßπ Eski i≈ülem temizleme isteƒüi:', { beforeDate, dryRun });

      if (!beforeDate) {
        return res.status(400).json({
          success: false,
          message: 'Tarih belirtilmedi'
        });
      }

      const cutoffDate = new Date(beforeDate);
      
      if (isNaN(cutoffDate.getTime())) {
        return res.status(400).json({
          success: false,
          message: 'Ge√ßersiz tarih formatƒ±'
        });
      }

      // Silinecek i≈ülemleri bul
      const oldTransactions = await prisma.bankTransaction.findMany({
        where: {
          transactionDate: {
            lt: cutoffDate
          }
        },
        include: {
          paymentMatches: true
        }
      });

      if (oldTransactions.length === 0) {
        return res.json({
          success: true,
          message: 'Silinecek eski i≈ülem bulunamadƒ±',
          data: {
            deletedCount: 0,
            totalAmount: 0,
            dryRun: dryRun
          }
        });
      }

      if (dryRun) {
        // Sadece √∂nizleme
        const totalAmount = oldTransactions.reduce((sum, tx) => sum + tx.amount, 0);
        
        return res.json({
          success: true,
          message: `DRY RUN: ${oldTransactions.length} eski i≈ülem silinecek`,
          data: {
            deletedCount: oldTransactions.length,
            totalAmount: totalAmount,
            dryRun: true,
            cutoffDate: cutoffDate,
            preview: oldTransactions.slice(0, 10).map(tx => ({
              id: tx.id,
              date: tx.transactionDate,
              amount: tx.amount,
              direction: tx.direction,
              description: tx.counterpartyName
            }))
          }
        });
      }

      // Ger√ßek silme i≈ülemi
      const transactionIds = oldTransactions.map(tx => tx.id);
      
      // ƒ∞li≈ükili e≈üle≈ütirmeleri sil
      await prisma.paymentMatch.deleteMany({
        where: { bankTransactionId: { in: transactionIds } }
      });

      // ƒ∞≈ülemleri sil
      await prisma.bankTransaction.deleteMany({
        where: {
          transactionDate: {
            lt: cutoffDate
          }
        }
      });

      const totalAmount = oldTransactions.reduce((sum, tx) => sum + tx.amount, 0);

      return res.json({
        success: true,
        message: `${oldTransactions.length} eski i≈ülem ba≈üarƒ±yla silindi`,
        data: {
          deletedCount: oldTransactions.length,
          totalAmount: totalAmount,
          cutoffDate: cutoffDate,
          dryRun: false
        }
      });

    } catch (error) {
      logError('Eski i≈ülem temizleme hatasƒ±:', error);
      return res.status(500).json({
        success: false,
        message: 'Eski i≈ülemler silinirken hata olu≈ütu',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  // Yeni PDF ETL i≈üleme endpoint'i
  async processPDFWithETL(req: Request, res: Response) {
    try {
      if (!req.file) {
        return res.status(400).json({
          success: false,
          message: 'PDF dosyasƒ± y√ºklenmedi'
        });
      }

      const filePath = req.file.path;
      console.log(`üìÑ PDF ETL i≈üleme ba≈ülatƒ±lƒ±yor: ${filePath}`);

      const result = await processPDFToDatabase(filePath);

      if (result.success) {
        return res.json({
          success: true,
          message: result.message,
          data: {
            processedCount: result.count,
            filePath: filePath
          }
        });
      } else {
        return res.status(400).json({
          success: false,
          message: result.message
        });
      }

    } catch (error) {
      logError('PDF ETL i≈üleme hatasƒ±:', error);
      return res.status(500).json({
        success: false,
        message: 'PDF i≈üleme sƒ±rasƒ±nda hata olu≈ütu',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
} 